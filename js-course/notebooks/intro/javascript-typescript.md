<div align='center'>
  <h1> JavaScript vs TypeScript </h1>
</div>

# Table of Contents

- [JavaScript](#javascript)
  - [Notes](#notes)
- [TypeScript](#TypeScript)
  - [Features](#features)
  - [Examples](#examples)
- [Summary](#summary)

# JavaScript

JavaScript is a high-level, `event-driven` and `single-threaded` programming language, `free of deadlocks`. JavaScript was initially designed to be `interpreted`, however, modern JavaScript engines, such as V8 (used in Google Chrome and Node.js) and SpiderMonkey (used in Firefox), use [JIT](https://en.wikipedia.org/wiki/Just-in-time_compilation) compilation. In JavaScript, functions are treated as [first-class citizens](https://en.m.wikipedia.org/wiki/First-class_function), i.e., they can be passed as arguments to other functions. In the functional programming style, [higher-order functions](https://en.m.wikipedia.org/wiki/Higher-order_function) are a standard practice.

- **Pros:** beginner-friendly with a faster learning curve. Flexible, allowing scripts to run even in the presence of errors. Since it is dynamic typing, type-checking is done at runtime.
- **Cons:** does not flag semantic errors, such as reassigning the data type of a variable by mistake, which might break the API. As the codebase grows in complexity and number of contributors, it gets increasingly difficult to find runtime errors and debug.

## Notes

- `Core`: is a physical processing unit inside the CPU that executes instructions. Usually, a single core can handle up to 2 threads.

- `Thread`: is a lightweight, logical unit of execution within a single process. All threads in the same process share the same memory space. While a single CPU core can execute up to 2 threads concurrently from a single process using features like **Simultaneous Multithreading (SMT)** (e.g., Hyper-Threading), thousands of threads can be executed over time through **context switching** by the operating system.

- `Single-threaded Programming`: instructions are executed one task at a time, sequentially, in order, in a single call stack and, therefore, in a synchronous way (no parallelism). Suitable for **minimal data I/O operations**.

- `Deadlock`: deadlock is a problem in concurrent programming where two or more processes are waiting for each other to release resources, creating a cycle of dependencies that prevents any of them from proceeding.

- `Interpreter`: executes the source code **line-by-line** or interprets bytecode at **runtime**, without compiling it to machine code in advance.

  - Example: Python's [CPython interpreter/compiler](https://en.wikipedia.org/wiki/CPython#:~:text=CPython%20can%20be%20defined%20as,a%20language%20other%20than%20Python.) first compiles source code to bytecode (`.pyc`), which it then interprets at runtime. Not all Interpreters rely on bytecode.
  - Pros: instantaneous code execution without the compilation step.
  - Cons: slower code execution due to interpretation overhead.
  - Suitable for: dynamic typed languages, such as `Python`.

- `Ahead-of-Time (AOT) Compiler`: translates the entire source code into machine code (binary code) **at compile time** (before execution). The output is specific to a given CPU architecture (e.g., x86, ARM) to run.

  - Pros: faster code execution (improves runtime performance).
  - Cons: has a cold (slower) start due to the compilation step.
  - Suitable for: statically typed languages, such as `C`, `C++`, `Rust`, and `Go`.

- `Transpiler`: converts source code from **one high-level language/version to another** (e.g., TypeScript --> JavaScript or ES6+ --> ES5).

- `Just-In-Time (JIT) Compiler`: JIT compilation is an optimization technique that combines **compilation and interpretation**. It allows programs to run faster by compiling frequently used parts (a.k.a hot spots) of the code to machine code **at runtime**.

  - Example: the [JavaScript engine](../advanced/js-internals/runtime-env.md) initially compiles JS source code into an intermediate representation (often bytecode) to be interpreted (not necessarily line-by-line). During execution, the interpreter keeps track of which parts (hot spots) of the intermediate code are executed frequently. These hot spots are JIT compiled into native machine code at runtime and used during future executions to improve runtime performance.
  - Suitable for: dynamic typed languages, such as `Modern JavaScript`, and newer versions of `Python`, `Ruby`, and `PHP`.

- `Bytecode:` is an intermediate, machine-independent representation of source code, usually generated by a compiler. It can be interpreted by an Interpreter, executed by a virtual machine or compiled to machine code at runtime using a JIT compiler.

- `Binary Code (machine code):` is the low-level code that is directly executable by the CPU. It is generated by a Compiler and is machine-specific, meaning it is tailored to the architecture of a given CPU.

# TypeScript

TypeScript is a superset of JavaScript, i.e., it includes all JavaScript features and extends its functionalities by providing static type annotations while enforcing type checking.

- **Pros:** static typing can flag errors at compile time before runtime.
- **Cons:** TypeScript features can make the code more verbose. Code must be transpiled into JavaScript to run in the browser.

## Features

TypeScript introduced:

- `Type annotations:` are used to provide hints about the data type of a variable, parameter, function, and other constructs.
- `Access modifiers:` can be **public**, **private**, **protected**, or **read-only**. Are used to define the visibility and accessibility of classes, methods, and member variables.
- `Interfaces:` are used to define the structure of an object, i.e., the data type of the properties of an object. In VsCode, TypeScript interfaces are implemented to enable code hints.

## Examples

To run `.ts` files, install the TypeScript compiler:

```bash
npm install -g typescript
```

Since JavaScript is dynamically typed, when using a JavaScript runtime environment (e.g. node.js), trying to reassign a variable that has already been declared does not render a compile-time error.

```javascript
// node message.js
let message = "message";
message = 10;
```

In TypeScript, it is possible to reassign a variable that has already been assigned, but the new value must match the type of the variable, otherwise it will render a compile-time error:

```typescript
// tsc message.ts
let message: string = "message";
message = 10; // ERROR: Type 'number' is not assignable to type 'string'.
```

It is also possible to write JavaScript code and still leverage TypeScript functionality. To achieve this, use `.ts` file extension and run the code through a TypeScript compiler, which will infer the data type of the variable based on the value assigned to it.

```javascript
// tsc message.ts
let message = "message";
message = 10; // ERROR: Type 'number' is not assignable to type 'string'.
```

# Summary

TypeScript can be gradually integrated into a JavaScript workflow as the project becomes more complex. Make sure to change file extensions to .ts and use a TypeScript compiler.

- JavaScript is recommended for small-scale applications that require fast prototyping.
- TypeScript is recommended for code maintainability of complex large-scale enterprise applications (such as VsCode) with many potential contributors.
